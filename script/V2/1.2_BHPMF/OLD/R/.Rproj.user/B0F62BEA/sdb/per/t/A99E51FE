{
    "contents" : "GapFilling <- function(X, hierarchy.info, prediction.level,\n        used.num.hierarchy.levels, num.samples=1000, burn=100, gaps=2,\n        num.latent.feats=10, tuning=FALSE, num.folds=5, tmp.dir,\n\t\tmean.gap.filled.output.path, std.gap.filled.output.path,\n\t\trmse.plot.test.data=TRUE) {\n# This function calculate the average RMSE in cross validation.\n  #\n  # Args:\n  #   X: A matrix containing the missing values, rows are the observations,\n  #      and columns are the features. Missing values are filled by NA.\n  #   hierarchy.info: A matrix containing the hierarchical info\n  #      in the format of taxa-table.\n  #   prediction.level: The level at which gaps are filled.\n  #      e.g., =4, filling gaps at leaves with a hierarchy informaiton of 3 levels.\n  #\t\t The default value is at the observation level.\n  #   used.num.hiearchy.levels: Number of hierarchy levels that is used for gap filling.\n  #      e.g., =2 means using only the first and second level of hierarchy.\n  #      It should between 1 and total number of hierarchy.\n  #\t\t The default value is total number of hierarchy level.\n  #   num.samples: Total number of generated samples at each fold using gibbs sampling.\n  #      It is not the effective number of samples.\n  #\t\t The default value is 1000.\n  #   burn: Number of initial sampled parameters discarded. The default value is 100.\n  #   gaps: Gap between sampled parameters kept. The default value is 2.\n  #\t  num.latent.feats: Size of latent vectors in BHPMF. Set it if tuning is False.\n  #\t  \t The default value is 10.\n  #\t  tuning: If set true, first tune BHPMF to choose the best value of num.latent.feats.\n  #\t  \t The default value is False.\n  #   num.folds: Number of cross validation (CV) folds used in tuning. The default value is 10.\n  #\t  tmp.dir: A temporary directory used to save preprocessing files.\n  #\t  \t If not provided, a tmp directory in /R/tmp will be created.\n  #\t\t If provided, each time calling a function from this package, will use the saved\n  #\t\t preprocessing files saved in this directory, it helps to avoid running preprocessing\n  #\t\t functions for the same input.\n  #\t\t WARNING: This directory should be empty for the first time call on a new dataset.\n  #\t  mean.gap.filled.output.path: A file path for saving the mean value of gap filled data.\n  #\t  \t In the same format as the input X.\n  #\t  \t It contain the prediction for both missing and observed values.\n  #\t  std.gap.filled.output.path: A file path for saving the std value of gap filled data.\n  #\t  \t In the same format as the input X.\n  #\t  rmse.plot.test.data: If TRUE, provide the rmse vs std plot for test data.\n  #\n  # Returns:\n  #   The average RMSE in cross validation\n\n    source(\"file_exists.R\")\n    source(\"preprocess_cv.R\")\n\tsource(\"plot_rmse_std.R\")\n\tnum.hierarchy.levels <- ncol(hierarchy.info)\n\tnum.cols <- ncol(X)\n\n    # Check missing arguments\n    if (missing(X)) {\n\t    stop(\"Missing X!\")\n    }\n    if (missing(hierarchy.info)) {\n\t    stop(\"Missing hierarchy.info!\")\n    }\n    if (missing(mean.gap.filled.output.path)) {\n       stop(\"A file path for mean.gap.filled.output.path should be provided.\")\n    }\n\tif (missing(std.gap.filled.output.path)) {\n\t   stop(\"A file path for std.gap.filled.output.path should be provided.\")\n\t}\n    if (missing(used.num.hierarchy.levels)) {\n        used.num.hierarchy.levels <- num.hierarchy.levels-1\n    }\n    if (missing(prediction.level)) {\n       prediction.level <- num.hierarchy.levels\n    }\n\tpreprocess.flag <- FALSE\n    if (missing(tmp.dir)) {\n       tmp.dir <- paste(tempdir(), \"/BHPMFAuthorsTmp\", sep = \"\")\n       if (file.exists(tmp.dir)) {\n          unlink(tmp.dir, recursive = TRUE, force = TRUE)\n       }\n       dir.create(tmp.dir)\n       preprocess.flag <- TRUE\n    } else if (!file.exists(tmp.dir)) {\n       stop(\"tmp.dir: \", tmp.dir, \"  does not exist\")\n    }\n\n    if (!preprocess.flag) {   # tmp directory is provided by user\n       if (!CheckPreprocessFilesExist(tmp.dir, 1, used.num.hierarchy.levels, prediction.level)) { # return TRUE if files exists\n          preprocess.flag <- TRUE\n       }\n    }\n\n\tcat(\"preprocess.flag: \",preprocess.flag, \"\\n\")\n\tnum.folds.cv1 <- 2\n\tif (tuning) {\n\t   num.folds.cv2 <- num.folds\n\t} else {\n\t   num.folds.cv2 <- 0\n\t}\n    if (preprocess.flag) {\n       PreprocessCv(X, hierarchy.info, num.folds.cv1, tmp.dir)\n       tmp.tune.dir = paste(tmp.dir, \"/fold1/Tunning\", sep=\"\")\n\t   cat(tmp.tune.dir)\n       dir.create(tmp.tune.dir)\n    }\n\n\tload(paste(tmp.dir, \"/processed_hierarchy_info.Rda\", sep=\"\"))\n\n\t#Tune the num.latent.feats parameter\n\t#By choosing the best parameter that minimize the\n\t#CV RMSE over training data in the first fold\n\t#Assumption: the best parameter is the same for other folds\n    if (tuning) {\n       cat(\"tuning: \")\n       source(\"tune_BHPMF.R\")\n       # find the X matrix for fold 1\n       file.name <- paste(tmp.dir, '/fold1/Ytrain', prediction.level, \".txt\", sep = \"\")\n       Y.tune <- as.matrix(read.table(file.name, sep=\"\\t\", header=F))\n       # X.tune <- sparseMatrix (Y.tune[,1], Y.tune[,2], x=Y.tune[,3])\n       X.tune <- matrix(data=NA, nrow=nrow(X), ncol=ncol(X))\n       X.tune[cbind(Y.tune[, 1], Y.tune[, 2])] <- Y.tune[, 3]\n       rm(Y.tune)\n\n       tmp.tune.dir = paste(tmp.dir, \"/fold1/Tunning\", sep=\"\")\n\n       out <- TuneBhpmf(X.tune, hierarchy.info, prediction.level, used.num.hierarchy.levels,\n                    num.folds, num.samples, burn, gaps, tmp.tune.dir)\n       rm(X.tune)\n       num.latent.feats <- out$BestNumLatentFeats\n    }\n\n\tsource(\"utillity.R\")\n\tdyn.load(\"../src/HPMF.so\")\n\n\tsave.file.flag <- 0\n\tout.whole.flag <- 1\n\tfold <- 1\n\topt <- 2\n\ttmp.env <- new.env()\n    args <- list(\"NumSamples\" = as.integer(num.samples),\n                 \"InputDir\" = tmp.dir,\n                 \"DatasetId\" = as.integer(fold),\n                 \"Gaps\" = as.integer(gaps),\n                 \"Burn\" = as.integer(burn),\n                 \"SaveFileFlag\" = as.integer(save.file.flag),\n                 \"OutWholeFlag\" = as.integer(out.whole.flag),\n                 \"NumTraits\" = as.integer(num.cols),\n                 \"NumFeats\" = as.integer(num.latent.feats),\n                 \"NumHierarchyLevel\" = as.integer(num.hierarchy.levels-1),\n                 \"PredictLevel\" = as.integer(prediction.level),\n                 \"UsedNumHierarchyLevel\" = as.integer(used.num.hierarchy.levels),\n                 \"Opt\" = as.integer(opt),\n                 \"Env\" = tmp.env\n                 )\n\n\tout <- .Call(\"DemoHPMF\", args, mean.gap.filled.output.path, std.gap.filled.output.path, num.nodes.per.level)\n\t\n\tgap.filled.dat = as.matrix(read.table(mean.gap.filled.output.path, sep=\"\\t\"))\n\tgap.filled.dat = gap.filled.dat[,1:ncol(X)]\n\tcolnames(gap.filled.dat) = colnames(X)\n\twrite.table(gap.filled.dat, file = mean.gap.filled.output.path, sep=\"\\t\", col.names = T, row.names = F)\n\n\tstd.filled.dat = as.matrix(read.table(std.gap.filled.output.path, sep=\"\\t\"))\n\tstd.filled.dat = std.filled.dat[,1:ncol(X)]\n\tcolnames(std.filled.dat) = colnames(X)\n\twrite.table(std.filled.dat, file = std.gap.filled.output.path, sep=\"\\t\", col.names = T, row.names = F)\n\n\tif (rmse.plot.test.data) {\n\n\t    file.name <- paste(tmp.dir, \"/fold1/Ytest\", prediction.level, \".txt\", sep = \"\")\n        test.data <- as.matrix(read.table(file.name))\n\t\trow.idx <- test.data[,1]\n\t\tcol.idx <- test.data[,2]\n\t\tnrows <- nrow(X)\n\t    test.idx <- (col.idx - 1) * nrows + row.idx\n\n\t\ttest.mean <- gap.filled.dat[test.idx]\n\t\ttest.res <- test.mean - test.data[, 3]\n        test.rmse <- sqrt(mean(test.res^2));\n\t\tcat(\"RMSE for the test data: \", test.rmse)\n\n\t\ttest.std <- std.filled.dat[test.idx]\n\t   \tPlotRmseVsStd(test.res, test.std)\n\t}\t\n}",
    "created" : 1439279964793.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3850798328",
    "id" : "A99E51FE",
    "lastKnownWriteTime" : 1438584644,
    "path" : "M:/projects/FDiversity/hierarchy/hpmf_method_paper/scripts/HPMF_v1.6/R/gap_filling.R",
    "project_path" : "gap_filling.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}